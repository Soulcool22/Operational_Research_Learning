# 整数规划｜设施选址优化问题

## 什么是整数规划？

整数规划指在优化问题中，部分变量被限制为整数（如 0 或 1）。在设施选址问题中，需要决定是否建设设施，属于典型的 0-1 整数规划。

## 核心代码实现

### 1. `solve_facility_location()`（设施选址求解）

用于确定在满足需求的前提下，使总成本最小的设施选址方案。

**完整代码步骤：**

```python
def solve_facility_location(self):
    # 第1步：定义问题数据
    locations = ['地点A', '地点B', '地点C', '地点D', '地点E']
    construction_cost = [500, 400, 600, 350, 450]  # 建设成本（万元）
    operating_cost = [80, 70, 90, 60, 75]          # 年运营成本（万元）
    capacity = [1200, 1000, 1500, 800, 1100]       # 服务能力（万件/年）
    total_demand = 3000                             # 总需求（万件/年）
  
    # 第2步：创建优化问题
    prob = pulp.LpProblem("设施选址", pulp.LpMinimize)
  
    # 第3步：定义决策变量（0-1变量）
    y = [pulp.LpVariable(f"y{i}", cat='Binary') for i in range(5)]
  
    # 第4步：设置目标函数（最小化总成本）
    total_cost = pulp.lpSum([(construction_cost[i] + 5 * operating_cost[i]) * y[i] 
                            for i in range(5)])
    prob += total_cost
  
    # 第5步：添加约束条件
    prob += pulp.lpSum(y) == 3                    # 必须选3个地点
    prob += pulp.lpSum([capacity[i] * y[i] for i in range(5)]) >= total_demand  # 满足需求
  
    # 第6步：求解
    prob.solve(pulp.PULP_CBC_CMD(msg=0))
  
    # 第7步：读取结果
    selected = [int(y[i].varValue) for i in range(5)]
    min_cost = pulp.value(prob.objective)
```

**说明：**

- `pulp.LpVariable(name, cat='Binary')`：创建 0-1 变量。
- `pulp.LpProblem(name, pulp.LpMinimize)`：创建最小化问题。
- `pulp.lpSum()`：求和函数。
- `prob += 约束条件`：添加约束。
- `prob.solve()`：求解问题。
- `变量.varValue`：获取变量的最优值。

### 2. `solve_knapsack_problem()`（背包问题求解）

用于在容量约束下选择物品，使总价值最大。

**完整代码步骤：**

```python
def solve_knapsack_problem(self):
    # 第1步：定义物品数据
    items = ['笔记本电脑', '平板电脑', '智能手机', '耳机', '充电宝']
    values = [8000, 3000, 5000, 1500, 800]      # 价值（元）
    weights = [2.5, 1.2, 0.8, 0.3, 0.5]        # 重量（kg）
    capacity = 5.0                               # 背包容量（kg）
  
    # 第2步：创建优化问题
    prob = pulp.LpProblem("背包问题", pulp.LpMaximize)
  
    # 第3步：定义决策变量
    x = [pulp.LpVariable(f"x{i}", cat='Binary') for i in range(len(items))]
  
    # 第4步：设置目标函数（最大化价值）
    total_value = pulp.lpSum([values[i] * x[i] for i in range(len(items))])
    prob += total_value
  
    # 第5步：添加重量约束
    prob += pulp.lpSum([weights[i] * x[i] for i in range(len(items))]) <= capacity
  
    # 第6步：求解并读取结果
    prob.solve(pulp.PULP_CBC_CMD(msg=0))
    selected_items = [int(x[i].varValue) for i in range(len(items))]
    max_value = pulp.value(prob.objective)
```

**说明：**

- `pulp.LpMaximize`：最大化问题。
- `<=` 与 `>=`：不等式约束。
- `len(items)`：获取列表长度。
- 循环创建变量：`[变量 for i in range(n)]`。

### 3. `visualize_results()`（结果可视化）

将优化结果绘制为图表，便于理解与对比。

**完整代码步骤：**

```python
def visualize_results(self):
    # 第1步：设置图表
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))
  
    # 第2步：绘制设施选址结果
    colors = ['#FF6B6B' if selected else '#DDD' 
             for selected in self.results['selected']]
    bars1 = ax1.bar(self.results['locations'], self.results['capacity'], color=colors)
    ax1.set_title('设施选址结果', fontsize=14, fontweight='bold')
    ax1.set_ylabel('服务能力 (万件/年)')
  
    # 第3步：添加选中标记
    for i, (bar, selected) in enumerate(zip(bars1, self.results['selected'])):
        if selected:
            ax1.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 20,
                    '✓', ha='center', va='bottom', fontsize=16, color='red')
  
    # 第4步：绘制背包问题结果
    knapsack = self.results['knapsack']
    colors = ['#32CD32' if selected else '#DDD' 
             for selected in knapsack['selected_items']]
    bars2 = ax2.bar(knapsack['items'], knapsack['values'], color=colors)
    ax2.set_title('背包问题 - 物品选择', fontsize=14, fontweight='bold')
  
    # 第5步：保存图表
    plt.savefig('integer_programming_results.png', dpi=300, bbox_inches='tight')
```

**语法要点：**

- `plt.subplots(1, 2)`：创建1行2列的子图
- `ax.bar()`：绘制柱状图
- `ax.text()`：添加文字标注
- `enumerate(zip())`：同时遍历多个列表
- `plt.savefig()`：保存图片

### 4. `scenario_analysis()`（情景分析）

分析不同需求量下最优方案的变化趋势。

**完整代码步骤：**

```python
def scenario_analysis(self):
    # 第1步：设置不同的需求量
    base_demand = self.results['total_demand']
    for demand_change in [0.8, 0.9, 1.1, 1.2]:  # 需求量变化倍数
        new_demand = base_demand * demand_change
    
        # 第2步：重新建立优化问题
        prob = pulp.LpProblem("情景分析", pulp.LpMinimize)
        y = [pulp.LpVariable(f"y{i}", cat='Binary') for i in range(5)]
    
        # 第3步：重新求解
        prob.solve(pulp.PULP_CBC_CMD(msg=0))
    
        # 第4步：输出结果
        if prob.status == 1:  # 有最优解
            new_cost = pulp.value(prob.objective)
            print(f"需求量 {new_demand:.0f} 万件/年: 总成本 {new_cost:.2f} 万元")
```

**说明：**

- `for 变量 in 列表`：循环遍历。
- `prob.status == 1`：检查是否有最优解。
- `f"字符串{变量:.2f}"`：格式化输出（保留两位小数）。

### 5. `generate_report()`（生成报告）

将所有结果整理为报告摘要。

**完整代码步骤：**

```python
def generate_report(self):
    # 第1步：输出问题概述
    print("设施选址问题：")
    print("  • 优化目标: 最小化总成本")
    print("  • 决策变量: 是否在候选地点建设设施")
  
    # 第2步：输出最优方案
    print("最优方案：")
    for detail in self.results['selected_details']:
        print(f"  • {detail['location']}: 建设成本 {detail['construction_cost']}万元")
  
    # 第3步：计算成本分析
    total_construction = sum(detail['construction_cost'] 
                           for detail in self.results['selected_details'])
    total_operating = sum(detail['operating_cost'] * 5 
                        for detail in self.results['selected_details'])
  
    # 第4步：输出背包问题结果（如果有）
    if 'knapsack' in self.results:
        knapsack = self.results['knapsack']
        print(f"背包问题结果：")
        print(f"  • 选中物品: {', '.join(knapsack['selected_item_names'])}")
        print(f"  • 总价值: {knapsack['max_value']:.0f} 元")
```

**说明：**

- `sum(表达式 for 项 in 列表)`：求和表达式。
- `', '.join(列表)`：逗号连接列表元素。
- `if 'key' in 字典`：检查字典是否包含某个键。

## 运行方法

1. **直接运行脚本：**

   ```bash
   python integer_programming_demo.py
   ```
2. **作为模块导入：**

   ```python
   from integer_programming_demo import IntegerProgrammingDemo
   demo = IntegerProgrammingDemo()
   demo.solve_facility_location()
   demo.solve_knapsack_problem()
   ```

## 输出结果说明

**控制台输出：**

- 设施选址最优方案（选中的地点）
- 背包问题最优选择（选中的物品）
- 成本分析和价值分析
- 情景分析结果

**生成文件：**

- `integer_programming_results.png`：可视化图表

## 算法原理简介

**分支定界法（Branch and Bound）：**

1. **分支**：把问题分成更小的子问题
2. **定界**：计算每个子问题的上下界
3. **剪枝**：排除不可能包含最优解的分支
4. **求解**：找到最优的整数解

**为何使用整数规划**

- 有些决策只能是"是"或"否"（建设施、选物品）
- 普通线性规划可能给出小数解（比如建0.5个设施）
- 整数规划确保解的实际可行性

## 实际应用场景

1. **设施选址**：工厂、仓库、医院、学校的选址
2. **资源分配**：人员排班、设备配置
3. **投资决策**：项目选择、资产组合
4. **生产计划**：批量生产、库存管理

## 技术要点

1. **PuLP库使用**：

   - `LpVariable(cat='Binary')`：0-1变量
   - `LpVariable(cat='Integer')`：整数变量
   - `PULP_CBC_CMD(msg=0)`：静默求解
2. **约束条件设置**：

   - 等式约束：`prob += 表达式 == 值`
   - 不等式约束：`prob += 表达式 <= 值`
3. **结果处理**：

   - `prob.status`：求解状态（1=最优，0=不可行）
   - `变量.varValue`：变量的最优值
   - `pulp.value(prob.objective)`：目标函数最优值
4. **可视化技巧**：

   - 用颜色区分选中与未选中。
   - 添加标记符号（✓）。
   - 统一图表样式与中文标签。
