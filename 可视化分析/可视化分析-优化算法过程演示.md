# 可视化分析｜优化算法过程演示

## 问题背景
运筹学中的优化问题往往比较抽象，通过可视化可以直观地理解：
- **线性规划的可行域**：约束条件围成的区域在哪里？最优解为什么在顶点？
- **梯度下降过程**：算法是如何一步步找到最优解的？
- **网络流问题**：货物在网络中是如何流动的？
- **参数敏感性**：改变一个参数，结果会发生多大变化？
- **三维优化表面**：复杂函数的"山峰"和"山谷"长什么样？

这个模块用6个可视化函数，把这些抽象概念变成直观的图表。

## 核心代码实现

### 1. 线性规划可行域可视化：`linear_programming_feasible_region()`

**作用**：画出约束条件围成的可行域，显示最优解位置。

**关键代码步骤**：

**步骤1：创建约束条件**
```python
# 约束条件：2x + 3y <= 12, x + 2y <= 8, x >= 0, y >= 0
constraint1 = (2*X + 3*Y <= 12)
constraint2 = (X + 2*Y <= 8)
constraint3 = (X >= 0)
constraint4 = (Y >= 0)

# 可行域 = 所有约束的交集
feasible = constraint1 & constraint2 & constraint3 & constraint4
```

**步骤2：绘制约束线**
```python
# 约束线方程：2x + 3y = 12 → y = (12 - 2x) / 3
y1 = (12 - 2*x) / 3
y2 = (8 - x) / 2

ax.plot(x, y1, 'r-', linewidth=2, label='2x + 3y ≤ 12')
ax.plot(x, y2, 'b-', linewidth=2, label='x + 2y ≤ 8')
```

**步骤3：填充可行域**
```python
# 用绿色填充可行域
ax.contourf(X, Y, feasible.astype(int), levels=[0.5, 1.5], 
           colors=['lightgreen'], alpha=0.5)
```

**步骤4：绘制目标函数等高线**
```python
# 目标函数：max 3x + 2y，画出不同利润水平的等高线
for c in [6, 9, 12, 15]:
    y_obj = (c - 3*x) / 2  # 3x + 2y = c → y = (c - 3x) / 2
    ax.plot(x, y_obj, '--', alpha=0.7, label=f'3x + 2y = {c}')
```

**通俗解释**：
- `constraint1 & constraint2`：用逻辑与操作找到同时满足多个约束的区域
- `contourf()`：填充函数，把满足条件的区域涂上颜色
- 等高线：同一条线上的点有相同的目标函数值（利润）

### 2. 梯度下降优化过程：`optimization_process_animation()`

**作用**：展示梯度下降算法如何一步步找到最优解。

**关键代码步骤**：

**步骤1：定义目标函数和梯度**
```python
def objective_function(x, y):
    return (x - 3)**2 + (y - 2)**2  # 最优解在(3, 2)

def gradient(x, y):
    return np.array([2*(x-3), 2*(y-2)])  # 梯度 = 导数
```

**步骤2：梯度下降迭代**
```python
learning_rate = 0.1  # 学习率：步长大小
current_x, current_y = 0.5, 0.5  # 起始点

for i in range(max_iterations):
    grad = gradient(current_x, current_y)  # 计算当前梯度
    current_x -= learning_rate * grad[0]   # 沿负梯度方向移动
    current_y -= learning_rate * grad[1]
    
    path_x.append(current_x)  # 记录路径
    path_y.append(current_y)
```

**步骤3：绘制优化路径**
```python
# 等高线图显示函数形状
contour = ax.contour(X, Y, Z, levels=20, alpha=0.6)

# 优化路径：红色圆点连线
ax.plot(path_x, path_y, 'ro-', linewidth=2, markersize=6, 
       label='梯度下降路径')

# 添加箭头显示移动方向
for i in range(0, len(path_x)-1, 3):
    ax.annotate('', xy=(path_x[i+1], path_y[i+1]), 
               xytext=(path_x[i], path_y[i]),
               arrowprops=dict(arrowstyle='->', color='red'))
```

**通俗解释**：
- `learning_rate`：学习率，控制每次移动的步长，太大会震荡，太小会很慢
- `gradient()`：梯度指向函数增长最快的方向，负梯度指向下降最快的方向
- 路径可视化：看到算法是如何"下山"找到最低点的

### 3. 网络流可视化：`network_flow_visualization()`

**作用**：展示供应-中转-需求网络中的货物流动。

**关键代码步骤**：

**步骤1：构建网络图**
```python
import networkx as nx

G = nx.DiGraph()  # 有向图

# 添加节点
supply_nodes = ['S1', 'S2', 'S3']      # 供应商
demand_nodes = ['D1', 'D2', 'D3', 'D4'] # 客户
intermediate_nodes = ['T1', 'T2']       # 中转站

# 添加边和容量
edges_with_capacity = [
    ('S1', 'T1', 50), ('S1', 'T2', 40),  # (起点, 终点, 容量)
    ('T1', 'D1', 35), ('T1', 'D2', 25),
    # ... 更多边
]

for source, target, capacity in edges_with_capacity:
    G.add_edge(source, target, capacity=capacity, flow=0)
```

**步骤2：设置节点位置**
```python
# 手动设置节点位置，保证图形美观
pos = {
    'S1': (0, 2), 'S2': (0, 1), 'S3': (0, 0),    # 供应商在左侧
    'T1': (2, 1.5), 'T2': (2, 0.5),              # 中转站在中间
    'D1': (4, 2), 'D2': (4, 1.5), 'D3': (4, 0.5), 'D4': (4, 0)  # 客户在右侧
}
```

**步骤3：绘制网络结构**
```python
# 不同类型节点用不同颜色
node_colors = ['lightcoral' if node in supply_nodes 
              else 'lightblue' if node in demand_nodes 
              else 'lightgreen' for node in G.nodes()]

nx.draw(G, pos, with_labels=True, node_color=node_colors,
       node_size=1500, arrows=True, arrowsize=20)
```

**步骤4：显示流量结果**
```python
# 根据流量调整边的粗细和颜色
for u, v, d in G.edges(data=True):
    flow_ratio = d['flow'] / d['capacity']  # 流量比例
    width = 1 + 4 * flow_ratio              # 线条粗细
    color = plt.cm.Reds(0.3 + 0.7 * flow_ratio)  # 颜色深浅
    
    nx.draw_networkx_edges(G, pos, [(u, v)], width=width, edge_color=[color])
```

**通俗解释**：
- `nx.DiGraph()`：有向图，箭头表示流动方向
- `flow_ratio`：流量占容量的比例，用来控制线条粗细和颜色深浅
- 可视化效果：粗线表示流量大，细线表示流量小

### 4. 敏感性分析：`sensitivity_analysis()`

**作用**：分析参数变化对优化结果的影响。

**关键代码步骤**：

**步骤1：参数敏感性分析**
```python
c_values = np.linspace(1, 10, 50)  # 目标函数系数变化范围
optimal_values = []

for c in c_values:
    # 模拟最优值随参数变化（实际中需要重新求解）
    optimal_value = c * 5 - 0.1 * c**2  # 二次函数模拟
    optimal_values.append(optimal_value)

# 绘制敏感性曲线
ax.plot(c_values, optimal_values, 'b-', linewidth=2)
ax.fill_between(c_values, optimal_values, alpha=0.3)  # 填充区域
```

**步骤2：影子价格分析**
```python
b_values = np.linspace(5, 25, 50)  # 约束右端项变化
shadow_prices = []

for b in b_values:
    # 影子价格：约束放松一个单位带来的目标函数改善
    if b < 10:
        shadow_price = 2.0      # 资源稀缺时影子价格高
    elif b < 20:
        shadow_price = 2.0 - 0.1 * (b - 10)  # 逐渐降低
    else:
        shadow_price = 0        # 资源充足时影子价格为0
    shadow_prices.append(shadow_price)
```

**步骤3：多参数热力图**
```python
# 两个参数同时变化的影响
param1_range = np.linspace(0.5, 2.0, 20)
param2_range = np.linspace(1.0, 3.0, 20)
P1, P2 = np.meshgrid(param1_range, param2_range)

# 目标函数值随参数变化
Z_sensitivity = P1 * P2 * 10 - 0.5 * P1**2 - 0.3 * P2**2

# 热力图显示
ax.contourf(P1, P2, Z_sensitivity, levels=20, cmap='viridis')
```

**通俗解释**：
- 敏感性分析：看参数变化对结果的影响有多大
- 影子价格：增加一单位资源能带来多少收益
- 热力图：颜色深浅表示目标函数值大小

### 5. 三维优化表面：`three_dimensional_optimization()`

**作用**：展示复杂优化函数的三维形状。

**关键代码步骤**：

**步骤1：Rosenbrock函数（香蕉函数）**
```python
# 经典测试函数，有一个狭长的山谷
Z1 = (1 - X)**2 + 100 * (Y - X**2)**2

# 三维表面图
ax.plot_surface(X, Y, Z1, cmap='viridis', alpha=0.8)

# 底部等高线投影
ax.contour(X, Y, Z1, zdir='z', offset=0, cmap='viridis', alpha=0.5)

# 标记全局最优解
ax.scatter([1], [1], [0], color='red', s=100, label='全局最优')
```

**步骤2：Ackley函数（多峰函数）**
```python
# 有很多局部最优的复杂函数
Z2 = (-20 * np.exp(-0.2 * np.sqrt(0.5 * (X**2 + Y**2))) - 
      np.exp(0.5 * (np.cos(2*np.pi*X) + np.cos(2*np.pi*Y))) + 
      np.e + 20)

ax.plot_surface(X, Y, Z2, cmap='plasma', alpha=0.8)
```

**步骤3：约束优化问题**
```python
# 目标函数：最小化 x² + y²
Z3 = X**2 + Y**2

# 约束条件：x² + y² ≤ 9 且 x + y ≥ 1
constraint_mask = (X**2 + Y**2 <= 9) & (X + Y >= 1)
Z3_constrained = np.where(constraint_mask, Z3, np.nan)  # 约束外设为NaN

# 只绘制可行域内的表面
ax.plot_surface(X, Y, Z3_constrained, cmap='coolwarm', alpha=0.8)
```

**步骤4：帕累托前沿（多目标优化）**
```python
# 两个冲突的目标
t = np.linspace(0, 1, 100)
obj1 = t**2        # 目标1
obj2 = (1 - t)**2  # 目标2（与目标1冲突）
obj3 = t * (1 - t) # 目标3

# 帕累托前沿：无法同时改善所有目标的解集合
ax.plot(obj1, obj2, obj3, 'b-', linewidth=3, label='帕累托前沿')
```

**通俗解释**：
- `plot_surface()`：绘制三维表面，`cmap`控制颜色
- `np.where(constraint_mask, Z3, np.nan)`：只显示满足约束的部分
- 帕累托前沿：多目标优化中，改善一个目标必须牺牲另一个目标的解

### 6. 算法对比仪表板：`algorithm_comparison_dashboard()`

**作用**：对比不同优化算法的性能。

**关键代码步骤**：

**步骤1：收敛速度对比**
```python
iterations = np.arange(1, 51)

# 模拟不同算法的收敛曲线
gradient_descent = 100 * np.exp(-0.1 * iterations)  # 指数衰减
newton_method = 100 * np.exp(-0.3 * iterations)     # 更快收敛
genetic_algorithm = 100 - 2 * iterations             # 线性下降
simulated_annealing = 100 * np.exp(-0.05 * iterations) + 10 * np.sin(iterations/5)  # 有震荡

# 对数坐标显示
ax.set_yscale('log')
```

**步骤2：雷达图性能对比**
```python
algorithms = ['梯度下降', '牛顿法', '遗传算法', '模拟退火', '粒子群']
metrics = ['收敛速度', '全局搜索', '内存使用', '实现难度', '稳定性']

# 性能评分矩阵（1-10分）
scores = np.array([
    [8, 3, 9, 8, 7],  # 梯度下降：收敛快但易陷入局部最优
    [9, 4, 8, 6, 8],  # 牛顿法：收敛很快但实现复杂
    # ...
])

# 极坐标雷达图
ax = plt.subplot(projection='polar')
angles = np.linspace(0, 2*np.pi, len(metrics), endpoint=False)

for algorithm, score in zip(algorithms, scores):
    ax.plot(angles, score, 'o-', linewidth=2, label=algorithm)
    ax.fill(angles, score, alpha=0.1)
```

**通俗解释**：
- 收敛曲线：看哪个算法找到最优解更快
- 雷达图：多维度对比算法性能，面积越大越好
- 对数坐标：当数值差异很大时，便于观察变化趋势

## 运行方法

### 运行所有可视化
```bash
cd 可视化分析
python visualization_demo.py
```

### 单独运行某个可视化
```python
from visualization_demo import OptimizationVisualization
viz = OptimizationVisualization()

# 选择运行其中一个
viz.linear_programming_feasible_region()    # 线性规划可行域
viz.optimization_process_animation()        # 梯度下降过程
viz.network_flow_visualization()            # 网络流
viz.sensitivity_analysis()                  # 敏感性分析
viz.three_dimensional_optimization()        # 三维优化表面
viz.algorithm_comparison_dashboard()        # 算法对比
```

## 输出文件说明

运行后会生成6个PNG图表文件：

1. **`feasible_region.png`** - 线性规划可行域
   - 左图：简单约束的可行域和等利润线
   - 右图：复杂约束的可行域

2. **`optimization_process.png`** - 梯度下降优化过程
   - 等高线图显示函数形状
   - 红色路径显示算法搜索轨迹
   - 箭头显示移动方向

3. **`network_flow.png`** - 网络流可视化
   - 左图：网络结构和容量
   - 右图：流量分布（线条粗细表示流量大小）

4. **`sensitivity_analysis.png`** - 敏感性分析
   - 参数敏感性曲线
   - 影子价格变化
   - 双参数热力图
   - 稳定性区间

5. **`3d_optimization.png`** - 三维优化表面
   - Rosenbrock函数（香蕉函数）
   - Ackley函数（多峰函数）
   - 约束优化问题
   - 帕累托前沿

6. **`algorithm_comparison.png`** - 算法性能对比
   - 收敛速度对比
   - 雷达图性能评估
   - 时间复杂度分析
   - 成功率对比

## 技术要点

### 图表样式统一
```python
plt.style.use('seaborn-v0_8')    # 统一样式
setup_chinese_font()             # 中文字体支持
plt.grid(True, alpha=0.3)        # 网格线透明度
plt.savefig(path, dpi=300, bbox_inches='tight')  # 高质量输出
```

### 颜色和标记
- **节点颜色**：供应商（红色）、客户（蓝色）、中转站（绿色）
- **线条粗细**：表示流量大小或重要程度
- **透明度**：`alpha=0.3-0.8`，避免遮挡
- **标记**：起始点（绿色圆圈）、最优解（红色星号）

### 数学函数可视化
- **等高线**：`contour()`显示函数形状
- **表面图**：`plot_surface()`展示三维函数
- **填充**：`contourf()`和`fill_between()`突出区域
- **投影**：`zdir='z'`将三维图投影到底面

这个可视化模块把抽象的优化概念变成了直观的图表，帮助理解算法原理和优化过程！