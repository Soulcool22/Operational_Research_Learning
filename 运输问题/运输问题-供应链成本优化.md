# 运输问题｜供应链成本优化

## 问题背景
运输问题是运筹学中的经典优化问题：
- **物流配送**：从多个工厂向多个仓库运货，怎样安排最省钱？
- **供应链管理**：在满足需求的前提下，如何最小化运输成本？
- **资源调配**：有限的供应能力，如何合理分配给各个需求点？

本模块包含五个函数：基础运输求解、多产品运输、可视化、敏感性分析与报告生成。

## 核心代码实现

### 1. 基础运输问题求解：`solve_basic_transportation()`

**作用**：在满足工厂供应能力和仓库需求的前提下，计算从各工厂到各仓库的最优运输量，让总运输成本最小。

**关键代码步骤**：

**步骤1：定义问题数据**
```python
import pulp
import numpy as np

# 工厂和仓库
factories = ['工厂A', '工厂B', '工厂C']
warehouses = ['仓库1', '仓库2', '仓库3', '仓库4']

# 供应量（每个工厂能提供多少货物）
supply = [300, 400, 500]  # 吨

# 需求量（每个仓库需要多少货物）
demand = [250, 350, 400, 200]  # 吨

# 运输成本矩阵（从工厂i到仓库j运输1吨货物的成本）
cost_matrix = np.array([
    [8, 6, 10, 9],   # 工厂A到各仓库的成本
    [9, 12, 13, 7],  # 工厂B到各仓库的成本
    [14, 9, 16, 5]   # 工厂C到各仓库的成本
])
```

**步骤2：处理供需平衡**
```python
# 检查供应量是否等于需求量
total_supply = sum(supply)  # 总供应：1200吨
total_demand = sum(demand)  # 总需求：1200吨

if total_supply != total_demand:
    if total_supply > total_demand:
        # 供应过剩：添加虚拟仓库吸收多余供应
        demand.append(total_supply - total_demand)
        warehouses.append('虚拟仓库')
        # 虚拟仓库的运输成本为0（不产生实际成本）
        cost_matrix = np.column_stack([cost_matrix, np.zeros(3)])
    else:
        # 需求过剩：添加虚拟工厂满足多余需求
        supply.append(total_demand - total_supply)
        factories.append('虚拟工厂')
        # 虚拟工厂的运输成本为0
        cost_matrix = np.vstack([cost_matrix, np.zeros(len(warehouses))])
```

**步骤3：建立优化模型**
```python
# 创建最小化问题
prob = pulp.LpProblem("运输问题", pulp.LpMinimize)

# 决策变量：x[i,j] 表示从工厂i到仓库j的运输量
x = {}
for i in range(len(factories)):
    for j in range(len(warehouses)):
        x[i,j] = pulp.LpVariable(f"x_{i}_{j}", lowBound=0)

# 目标函数：最小化总运输成本
# 总成本 = Σ(运输量 × 单位成本)
prob += pulp.lpSum([cost_matrix[i][j] * x[i,j] 
                   for i in range(len(factories)) 
                   for j in range(len(warehouses))])
```

**步骤4：添加约束条件**
```python
# 供应约束：每个工厂的发货量不能超过其供应能力
for i in range(len(factories)):
    prob += pulp.lpSum([x[i,j] for j in range(len(warehouses))]) == supply[i]

# 需求约束：每个仓库的收货量必须满足其需求
for j in range(len(warehouses)):
    prob += pulp.lpSum([x[i,j] for i in range(len(factories))]) == demand[j]
```

**步骤5：求解和结果分析**
```python
# 求解：使用CBC求解器
prob.solve(pulp.PULP_CBC_CMD(msg=0))

# 获取最优解
solution_matrix = np.zeros((len(factories), len(warehouses)))
for i in range(len(factories)):
    for j in range(len(warehouses)):
        solution_matrix[i][j] = x[i,j].varValue

min_transport_cost = pulp.value(prob.objective)

print(f"最小运输成本: {min_transport_cost:.2f} 元")
print("最优运输方案:")
for i in range(len(factories)):
    for j in range(len(warehouses)):
        if solution_matrix[i][j] > 0:
            print(f"  {factories[i]} → {warehouses[j]}: {solution_matrix[i][j]:.1f}吨")
```

**说明**：
- `LpProblem()`：创建优化问题，指定目标为最小化成本。
- `LpVariable()`：决策变量，表示各路径运输量。
- `lpSum()`：求和函数，用于计算总成本或总运输量。
- `lowBound=0`：运输量为非负数。
- 虚拟节点：供需不平衡时，通过虚拟工厂或仓库实现平衡。

### 2. 多产品运输问题：`solve_multi_product_transportation()`

**作用**：处理多种产品同时运输的复杂情况，每个工厂可以生产多种产品，每个市场对多种产品都有需求。

**关键代码步骤**：

**步骤1：定义多维数据**
```python
# 工厂、产品、市场
factories = ['工厂X', '工厂Y']
products = ['产品P1', '产品P2']
markets = ['市场M1', '市场M2', '市场M3']

# 各工厂各产品的供应量（二维数组）
supply_matrix = np.array([
    [200, 150],  # 工厂X的P1, P2供应量
    [180, 220]   # 工厂Y的P1, P2供应量
])

# 各市场各产品的需求量（二维数组）
demand_matrix = np.array([
    [120, 100],  # 市场M1的P1, P2需求量
    [140, 130],  # 市场M2的P1, P2需求量
    [120, 140]   # 市场M3的P1, P2需求量
])

# 运输成本矩阵（三维数组：工厂×产品×市场）
cost_tensor = np.array([
    [[5, 7, 6],   # 工厂X的P1到各市场
     [6, 8, 7]],  # 工厂X的P2到各市场
    [[8, 6, 9],   # 工厂Y的P1到各市场
     [7, 5, 8]]   # 工厂Y的P2到各市场
])
```

**步骤2：建立三维决策变量**
```python
# 决策变量：x[i,p,j] 表示工厂i的产品p运到市场j的数量
x = {}
for i in range(len(factories)):
    for p in range(len(products)):
        for j in range(len(markets)):
            x[i,p,j] = pulp.LpVariable(f"x_{i}_{p}_{j}", lowBound=0)

# 目标函数：最小化总运输成本
prob += pulp.lpSum([cost_tensor[i][p][j] * x[i,p,j] 
                   for i in range(len(factories))
                   for p in range(len(products))
                   for j in range(len(markets))])
```

**步骤3：添加多维约束**
```python
# 供应约束：每个工厂每种产品的供应限制
for i in range(len(factories)):
    for p in range(len(products)):
        prob += pulp.lpSum([x[i,p,j] for j in range(len(markets))]) <= supply_matrix[i][p]

# 需求约束：每个市场每种产品的需求满足
for j in range(len(markets)):
    for p in range(len(products)):
        prob += pulp.lpSum([x[i,p,j] for i in range(len(factories))]) >= demand_matrix[j][p]
```

**说明**：
- 三维决策变量：`x[工厂, 产品, 市场]`，引入产品维度。
- 三维成本矩阵：不同工厂与产品在各市场的成本可能不同。
- 多维约束：同时考虑工厂的产品供应能力与市场的产品需求。

### 3. 结果可视化：`visualize_results()`

**作用**：把复杂的数字结果转化成直观的热力图，方便理解运输方案。

**关键代码步骤**：

**步骤1：准备图表数据**
```python
import matplotlib.pyplot as plt
import seaborn as sns

# 设置中文字体
setup_chinese_font()

# 创建双子图布局
fig = plt.figure(figsize=(14, 6))
```

**步骤2：绘制运输成本热力图**
```python
# 左图：运输成本矩阵
ax1 = plt.subplot(1, 2, 1)
sns.heatmap(cost_matrix, 
           xticklabels=warehouses,  # 横轴：仓库
           yticklabels=factories,   # 纵轴：工厂
           annot=True,              # 显示数值
           fmt='d',                 # 整数格式
           cmap='YlOrRd',          # 黄-橙-红色系
           ax=ax1)
ax1.set_title('运输成本矩阵 (元/吨)', fontsize=14, fontweight='bold')
```

**步骤3：绘制最优运输方案热力图**
```python
# 右图：最优运输方案
ax2 = plt.subplot(1, 2, 2)
sns.heatmap(solution_matrix, 
           xticklabels=warehouses,
           yticklabels=factories,
           annot=True,              # 显示运输量数值
           fmt='.1f',              # 保留1位小数
           cmap='Blues',           # 蓝色系
           ax=ax2)
ax2.set_title('最优运输方案 (吨)', fontsize=14, fontweight='bold')
```

**步骤4：保存图表**
```python
plt.tight_layout()
plt.savefig('transportation_results.png', dpi=300, bbox_inches='tight')
plt.close()
```

**说明**：
- `heatmap()`：热力图，颜色深浅表示数值大小。
- `annot=True`：在每个格子显示具体数值。
- `cmap='YlOrRd'`：成本用暖色系（红色表示高成本）。
- `cmap='Blues'`：运输量用冷色系（深蓝表示运输量大）。
- 对比两图：用于观察低成本路线是否被优先选择。

### 4. 成本敏感性分析：`cost_sensitivity_analysis()`

**作用**：分析当运输成本发生变化时，对总成本的影响程度。

**关键代码步骤**：

**步骤1：识别关键路线**
```python
# 分析前3条主要运输路线
main_routes = basic['route_details'][:3]

for route in main_routes:
    print(f"\n{route['from']} → {route['to']} 路线:")
    
    # 分析成本变化的影响
    for cost_change in [-20, -10, 10, 20]:  # 成本变化百分比
        # 计算成本变化对总成本的影响
        cost_impact = route['total_cost'] * cost_change / 100
        new_total_cost = base_cost + cost_impact
        
        print(f"  成本{cost_change:+d}% → 预估总成本: {new_total_cost:.2f} 元")
```

**说明**：
- 敏感性分析：评估关键路线的成本变化对总成本的影响。
- 正变化：成本上涨时的影响幅度。
- 负变化：成本下降时的影响幅度。
- 应用场景：识别需要重点关注与优化的运输路线。

### 5. 报告生成：`generate_report()`

**作用**：把技术结果转化成管理语言，生成业务决策报告。

**关键代码步骤**：

**步骤1：基础统计信息**
```python
print("运输问题优化报告")
print(f"最小运输成本: {basic['min_cost']:.2f} 元")

# 计算运输效率指标
total_quantity = sum(detail['quantity'] for detail in basic['route_details'])
avg_cost = basic['min_cost'] / total_quantity

print(f"总运输量: {total_quantity:.1f} 吨")
print(f"平均运输成本: {avg_cost:.2f} 元/吨")
print(f"活跃路线数: {len(basic['route_details'])}")
```

**步骤2：路线成本分析**
```python
# 找出最高成本和最低成本的路线
max_cost_route = max(basic['route_details'], key=lambda x: x['unit_cost'])
min_cost_route = min(basic['route_details'], key=lambda x: x['unit_cost'])

print(f"最高成本路线: {max_cost_route['from']} → {max_cost_route['to']} "
      f"({max_cost_route['unit_cost']} 元/吨)")
print(f"最低成本路线: {min_cost_route['from']} → {min_cost_route['to']} "
      f"({min_cost_route['unit_cost']} 元/吨)")
```

**步骤3：优化建议**
```python
# 基于成本分析给出建议
high_cost_routes = [r for r in basic['route_details'] if r['unit_cost'] > 10]
if high_cost_routes:
    print("建议：考虑优化高成本路线，寻找替代运输方案")

low_cost_routes = [r for r in basic['route_details'] if r['unit_cost'] < 8]
if low_cost_routes:
    print("建议：充分利用低成本路线，提高运输效率")
```

**说明**：
- 将数值结果整理为文字摘要。
- 识别关键路线与优化机会。
- 给出具体的管理建议。

## 运行方法

### 运行所有功能
```bash
cd 运输问题
python transportation_problem_demo.py
```

### 单独运行某个功能
```python
from transportation_problem_demo import TransportationProblemDemo
demo = TransportationProblemDemo()

# 选择运行其中一个
solution, cost = demo.solve_basic_transportation()        # 基础运输
multi_cost = demo.solve_multi_product_transportation()    # 多产品运输
demo.visualize_results()                                  # 可视化
demo.cost_sensitivity_analysis()                         # 敏感性分析
demo.generate_report()                                    # 生成报告
```

## 输出结果说明

### 控制台输出
运行后会显示详细的求解过程和结果：

**基础运输问题求解**：
```
基础运输问题 - 供应链优化
供需信息：
工厂供应量：{'工厂A': 300, '工厂B': 400, '工厂C': 500}
仓库需求量：{'仓库1': 250, '仓库2': 350, '仓库3': 400, '仓库4': 200}
总供应量：1200 吨
总需求量：1200 吨

运输成本矩阵（元/吨）：
        仓库1  仓库2  仓库3  仓库4
工厂A      8      6     10      9
工厂B      9     12     13      7
工厂C     14      9     16      5

最优运输方案：
        仓库1  仓库2  仓库3  仓库4
工厂A    0.0  300.0    0.0    0.0
工厂B  250.0    0.0    0.0  150.0
工厂C    0.0   50.0  400.0   50.0

最小运输成本：6200.00 元

主要运输路线：
  工厂 A → 仓库 2：300.0 吨，成本：1800.00 元
  工厂 B → 仓库 1：250.0 吨，成本：2250.00 元
  工厂 B → 仓库 4：150.0 吨，成本：1050.00 元
  工厂 C → 仓库 2：50.0 吨，成本：450.00 元
  工厂 C → 仓库 3：400.0 吨，成本：6400.00 元
  工厂 C → 仓库 4：50.0 吨，成本：250.00 元
```

**多产品运输问题**：
```
多产品运输问题
供应信息：
        产品P1  产品P2
工厂X      200     150
工厂Y      180     220

需求信息：
        产品P1  产品P2
市场M1      120     100
市场M2      140     130
市场M3      120     140

最优运输方案：
  最小运输成本：2280.00 元

运输路线详情：
  工厂 X 产品 P1 → 市场 M1：120.0 单位，成本：600.00 元
  工厂 X 产品 P1 → 市场 M3：80.0 单位，成本：480.00 元
  工厂 X 产品 P2 → 市场 M1：100.0 单位，成本：600.00 元
  工厂 X 产品 P2 → 市场 M2：50.0 单位，成本：400.00 元
  工厂 Y 产品 P1 → 市场 M2：140.0 单位，成本：840.00 元
  工厂 Y 产品 P1 → 市场 M3：40.0 单位，成本：360.00 元
  工厂 Y 产品 P2 → 市场 M2：80.0 单位，成本：400.00 元
  工厂 Y 产品 P2 → 市场 M3：140.0 单位，成本：1120.00 元
```

**优化报告**：
```
运输问题优化报告
基础运输问题：
  • 优化目标：最小化运输成本
  • 工厂数量：3
  • 仓库数量：4
  • 最小运输成本：6200.00 元

运输方案统计：
  • 总运输量：1200.0 吨
  • 平均运输成本：5.17 元/吨
  • 活跃路线数：6

路线成本分析：
  • 最高成本路线：工厂 C → 仓库 3（16 元/吨）
  • 最低成本路线：工厂 C → 仓库 4（5 元/吨）

优化建议：
  • 考虑优化高成本路线，寻找替代运输方案
  • 充分利用低成本路线，提高运输效率
```

### 图表文件
运行后会生成 `transportation_results.png` 文件，包含：

**运输成本矩阵热力图**（左图）：
- 横轴：仓库（仓库1、仓库2、仓库3、仓库4）
- 纵轴：工厂（工厂A、工厂B、工厂C）
- 颜色：暖色系，红色表示高成本，黄色表示低成本
- 数值：每个格子显示单位运输成本（元/吨）

**最优运输方案热力图**（右图）：
- 横轴：仓库
- 纵轴：工厂
- 颜色：冷色系，深蓝表示大运输量，浅蓝表示小运输量
- 数值：每个格子显示实际运输量（吨）

## 算法原理简介

### 运输问题基本概念
- **供应点**：有货物可以发出的地点（工厂）
- **需求点**：需要接收货物的地点（仓库、市场）
- **运输成本**：从供应点到需求点运输单位货物的费用
- **平衡问题**：总供应量等于总需求量

### 线性规划方法
- **目标函数**：最小化总运输成本 = Σ(运输量 × 单位成本)
- **决策变量**：各条路线的运输量
- **约束条件**：供应约束（不超过供应能力）+ 需求约束（满足需求）
- **最优解**：在满足所有约束的前提下，使总成本最小的运输方案

### 运输单纯形法
- **基本思想**：运输问题的特殊结构，可以用更高效的算法求解
- **初始解**：用西北角法、最小成本法等获得初始可行解
- **优化过程**：通过检验数判断是否最优，不最优则调整运输方案
- **收敛性**：有限步内必定收敛到最优解

### 虚拟节点处理
- **供应过剩**：添加虚拟仓库，运输成本为0，吸收多余供应
- **需求过剩**：添加虚拟工厂，运输成本为0，满足多余需求
- **意义**：将非平衡问题转化为平衡问题，便于求解

## 实际应用场景

### 物流配送优化
- **问题**：多个配送中心向多个客户配送，如何安排最省成本？
- **解决方案**：用运输问题模型优化配送路线和数量

### 生产计划调配
- **问题**：多个工厂生产同种产品，如何分配给各个销售区域？
- **解决方案**：考虑生产成本和运输成本，优化总体配置

### 资源分配优化
- **问题**：有限的资源如何在多个项目间分配？
- **解决方案**：将资源供应和项目需求建模为运输问题

### 多产品物流
- **问题**：多种产品同时配送，如何统筹安排？
- **解决方案**：用多产品运输模型，考虑产品差异化成本

## 技术要点

### PuLP运输问题建模
```python
import pulp

# 创建最小化问题
prob = pulp.LpProblem("运输问题", pulp.LpMinimize)

# 创建二维决策变量
x = {}
for i in range(m):  # m个供应点
    for j in range(n):  # n个需求点
        x[i,j] = pulp.LpVariable(f"x_{i}_{j}", lowBound=0)

# 目标函数：最小化总成本
prob += pulp.lpSum([cost[i][j] * x[i,j] for i in range(m) for j in range(n)])

# 供应约束
for i in range(m):
    prob += pulp.lpSum([x[i,j] for j in range(n)]) <= supply[i]

# 需求约束
for j in range(n):
    prob += pulp.lpSum([x[i,j] for i in range(m)]) >= demand[j]

# 求解
prob.solve()
```

### 多维数组处理
```python
import numpy as np

# 三维成本矩阵：工厂×产品×市场
cost_tensor = np.array([
    [[c111, c112, c113],  # 工厂1产品1到各市场
     [c121, c122, c123]], # 工厂1产品2到各市场
    [[c211, c212, c213],  # 工厂2产品1到各市场
     [c221, c222, c223]]  # 工厂2产品2到各市场
])

# 访问特定成本：工厂i的产品p到市场j
unit_cost = cost_tensor[i][p][j]
```

### 热力图可视化
```python
import seaborn as sns
import matplotlib.pyplot as plt

# 设置中文字体
setup_chinese_font()

# 绘制热力图
sns.heatmap(data_matrix,
           xticklabels=col_labels,    # 列标签
           yticklabels=row_labels,    # 行标签
           annot=True,                # 显示数值
           fmt='.1f',                # 数值格式
           cmap='Blues',              # 颜色映射
           cbar_kws={'label': '单位'}) # 颜色条标签

plt.title('标题', fontweight='bold')
plt.tight_layout()
plt.savefig('filename.png', dpi=300)
```

### 结果分析技巧
```python
# 提取非零运输路线
active_routes = []
for i in range(len(factories)):
    for j in range(len(warehouses)):
        if solution_matrix[i][j] > 0:
            active_routes.append({
                'from': factories[i],
                'to': warehouses[j],
                'quantity': solution_matrix[i][j],
                'cost': solution_matrix[i][j] * cost_matrix[i][j]
            })

# 按成本排序
active_routes.sort(key=lambda x: x['cost'], reverse=True)

# 计算统计指标
total_cost = sum(route['cost'] for route in active_routes)
total_quantity = sum(route['quantity'] for route in active_routes)
avg_cost = total_cost / total_quantity
```

## 扩展思考

### 模型改进方向
1. **容量约束**：考虑运输工具的容量限制
2. **时间窗约束**：考虑配送时间要求
3. **多目标优化**：同时考虑成本、时间、服务质量
4. **随机需求**：处理需求不确定的情况

### 实际应用注意事项
1. **数据准确性**：确保成本数据和供需数据准确
2. **模型验证**：检查模型结果是否符合实际约束
3. **敏感性分析**：了解参数变化对结果的影响
4. **实施可行性**：考虑实际操作中的限制条件

