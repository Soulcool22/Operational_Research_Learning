# 大规模优化｜多产品生产计划问题

## 问题背景

工厂有50种产品可以生产，但受到20种资源（如原材料、设备时间、人工等）的限制。每种产品消耗不同的资源，带来不同的利润。问题是：**在资源有限的情况下，生产多少数量的每种产品，才能获得最大利润？**

该问题属于大规模线性规划，相比小规模示例更贴近工厂实际。

## 核心代码实现

### 1. 数据生成函数：`generate_production_data()`

**作用**：创建模拟的工厂数据，包括产品利润、资源需求和资源容量。

**关键代码**：

```python
def generate_production_data(self, n_products=50, n_resources=20):
    # 产品名称：产品_01, 产品_02, ..., 产品_50
    products = [f'产品_{i+1:02d}' for i in range(n_products)]
  
    # 利润数据：基于正态分布生成，模拟真实情况
    profit = np.random.normal(100, 30, n_products)  # 平均100元，标准差30
    profit = np.maximum(profit, 10)  # 确保利润不低于10元
  
    # 资源需求矩阵：每个产品只用部分资源（稀疏矩阵）
    resource_matrix = np.zeros((n_products, n_resources))
    for i in range(n_products):
        n_used_resources = random.randint(3, 8)  # 每个产品用3-8种资源
        used_resources = random.sample(range(n_resources), n_used_resources)
        for j in used_resources:
            resource_matrix[i][j] = random.uniform(0.5, 5.0)  # 需求量0.5-5.0
```

**说明**：

- `np.random.normal(100, 30, n_products)`：生成50个利润数值，大部分在70-130元之间
- `random.randint(3, 8)`：每个产品随机使用3到8种资源，不是全部20种
- `random.uniform(0.5, 5.0)`：每单位产品消耗0.5到5.0单位的资源

### 2. 优化求解函数：`large_scale_linear_programming()`

**作用**：建立数学模型并求解生产方案，使利润最大化。

**关键代码步骤**：

**步骤1：创建优化问题**

```python
prob = pulp.LpProblem("大规模生产计划", pulp.LpMaximize)
```

- `LpProblem()`：创建一个优化问题
- `LpMaximize`：目标是最大化（利润）

**步骤2：定义决策变量**

```python
x = [pulp.LpVariable(f"x_{i}", lowBound=0) for i in range(len(products))]
```

- `LpVariable()`：创建决策变量，代表每种产品的产量
- `lowBound=0`：产量不能为负数

**步骤3：设置目标函数**

```python
prob += pulp.lpSum([profit[i] * x[i] for i in range(len(products))])
```

- `lpSum()`：求和函数，计算总利润
- `profit[i] * x[i]`：第i种产品的利润 × 产量

**步骤4：添加资源约束**

```python
for j in range(len(resources)):
    prob += pulp.lpSum([resource_matrix[i][j] * x[i] 
                       for i in range(len(products))]) <= capacity[j]
```

- 对每种资源j，所有产品消耗的总量不能超过资源容量
- `resource_matrix[i][j]`：产品i对资源j的需求量

**步骤5：求解**

```python
prob.solve(pulp.PULP_CBC_CMD(msg=0))
```

- `solve()`：调用求解器找到最优解
- `PULP_CBC_CMD(msg=0)`：使用CBC求解器，不显示详细信息

### 3. 结果分析函数

**获取解的值**：

```python
solution = [x[i].varValue if x[i].varValue else 0 for i in range(len(products))]
max_profit = pulp.value(prob.objective)
```

- `x[i].varValue`：获取变量x[i]的最优值（产量）
- `pulp.value(prob.objective)`：获取目标函数的最优值（最大利润）

**资源利用率计算**：

```python
resource_usage = np.zeros(len(resources))
for j in range(len(resources)):
    resource_usage[j] = sum(resource_matrix[i][j] * solution[i] 
                          for i in range(len(products)))
utilization_rates = resource_usage / capacity * 100
```

## 运行方法

### 方法1：直接运行整个演示

```bash
cd 大规模优化
python large_scale_optimization.py
```

### 方法2：只运行生产计划部分

```python
from large_scale_optimization import LargeScaleOptimization
demo = LargeScaleOptimization()
demo.large_scale_linear_programming()
```

## 输出结果说明

运行后将显示如下摘要输出：

```
求解结果：
  求解时间：0.02 秒
  最大利润：97,662.90 元
  生产产品数：10/50
  平均产量：95.38 单位

资源利用率统计：
  平均利用率：74.9%
  最高利用率：100.0%
  最低利用率：18.7%
  满负荷资源数：10
```

**结果解读**：

- 生产产品数 10/50：50 种产品中有 10 种被选定生产。
- 满负荷资源数 10：有 10 种资源达到或接近满负荷使用。
- 平均利用率 78.5%：资源整体利用率较高。

## 可视化图表

程序会生成 `large_scale_results.png`，包含：

1. **生产计划柱状图**：显示每种产品的最优产量
2. **资源利用率热力图**：显示哪些资源是瓶颈
3. **利润分布图**：显示不同利润水平的产品数量

---

# 全国物流网络优化问题

## 问题背景

全国有15个供应商（如工厂、仓库）和25个客户（如零售商、分销商），需要决定从哪个供应商向哪个客户发货，以及发货数量，目标是**在满足供需平衡的前提下，最小化总运输成本**。

该问题为运输问题的扩展规模版本，更接近真实的全国物流网络。

## 核心代码实现

### 1. 物流网络数据生成：`generate_logistics_network()`

**作用**：创建模拟的全国物流网络，包括供应商、客户、供需量和运输成本。

**关键代码**：

```python
def generate_logistics_network(self, n_suppliers=15, n_customers=25):
    # 使用真实城市名称
    cities = ['北京', '上海', '广州', '深圳', '天津', '重庆', '苏州', '成都', ...]
  
    # 随机选择供应商和客户城市
    all_cities = random.sample(cities, n_suppliers + n_customers)
    suppliers = all_cities[:n_suppliers]
    customers = all_cities[n_suppliers:]
  
    # 供应量：500-2000吨
    supply = np.random.uniform(500, 2000, n_suppliers)
  
    # 需求量：200-800吨，总需求略小于总供应
    demand = np.random.uniform(200, 800, n_customers)
    demand = demand * (sum(supply) * 0.95) / sum(demand)  # 调整为平衡
  
    # 运输成本 = 距离 × 单位成本 + 固定成本
    distance_matrix = np.random.uniform(200, 2000, (n_suppliers, n_customers))
    cost_matrix = distance_matrix * 0.8 + 50  # 0.8元/公里/吨 + 50元固定成本
```

**说明**：

- `random.sample(cities, n_suppliers + n_customers)`：从40个城市中随机选择40个作为供应商和客户
- `demand * (sum(supply) * 0.95) / sum(demand)`：确保总需求比总供应少5%，保证问题有解
- `distance_matrix * 0.8 + 50`：运输成本包含距离成本和固定成本

### 2. 运输优化求解：`large_scale_transportation()`

**关键代码步骤**：

**步骤1：创建运输问题**

```python
prob = pulp.LpProblem("大规模运输优化", pulp.LpMinimize)
```

- `LpMinimize`：目标是最小化（运输成本）

**步骤2：定义运输变量**

```python
x = {}
for i in range(len(suppliers)):
    for j in range(len(customers)):
        x[i,j] = pulp.LpVariable(f"x_{i}_{j}", lowBound=0)
```

- `x[i,j]`：从供应商i到客户j的运输量
- 使用字典存储二维变量，方便索引

**步骤3：设置目标函数**

```python
prob += pulp.lpSum([cost_matrix[i][j] * x[i,j] 
                   for i in range(len(suppliers)) 
                   for j in range(len(customers))])
```

- 最小化所有路线的运输成本总和

**步骤4：供应约束**

```python
for i in range(len(suppliers)):
    prob += pulp.lpSum([x[i,j] for j in range(len(customers))]) <= supply[i]
```

- 每个供应商的总发货量不能超过其供应能力

**步骤5：需求约束**

```python
for j in range(len(customers)):
    prob += pulp.lpSum([x[i,j] for i in range(len(suppliers))]) >= demand[j]
```

- 每个客户的总收货量必须满足其需求

### 3. 结果分析

**获取运输方案**：

```python
solution_matrix = np.zeros((len(suppliers), len(customers)))
for i in range(len(suppliers)):
    for j in range(len(customers)):
        if x[i,j].varValue:
            solution_matrix[i][j] = x[i,j].varValue
```

**统计活跃路线**：

```python
active_routes = sum(1 for i in range(len(suppliers)) 
                   for j in range(len(customers)) 
                   if solution_matrix[i][j] > 0.01)
```

---

# 车辆路径规划问题 (VRP)

## 问题背景

配送中心需要用4辆货车为20个客户送货，每辆车有载重限制，每个客户有不同的需求量。问题是：**如何安排车辆路线，使总行驶距离最短，同时满足载重约束？**

该问题为车辆路径问题（Vehicle Routing Problem）的示例，在物流配送场景中具有代表性。

## 核心代码实现

### 1. VRP数据生成

**关键代码**：

```python
def vehicle_routing_problem(self):
    # 问题参数
    n_customers = 20
    n_vehicles = 4
    vehicle_capacity = 100  # 车辆载重
  
    # 客户坐标（以配送中心为原点）
    depot_coord = (0, 0)
    customer_coords = [(random.uniform(-50, 50), random.uniform(-50, 50)) 
                      for _ in range(n_customers)]
  
    # 客户需求量：5-25单位
    demands = np.random.uniform(5, 25, n_customers)
  
    # 距离计算函数
    def calculate_distance(coord1, coord2):
        return np.sqrt((coord1[0] - coord2[0])**2 + (coord1[1] - coord2[1])**2)
```

**说明**：

- `depot_coord = (0, 0)`：配送中心位于坐标原点
- `random.uniform(-50, 50)`：客户随机分布在配送中心周围100×100的区域内
- `calculate_distance()`：使用欧几里得距离公式计算两点间距离

### 2. 贪心算法求解VRP

**算法逻辑**：

```python
def solve_vrp_greedy():
    routes = [[] for _ in range(n_vehicles)]  # 每辆车的路线
    route_loads = [0] * n_vehicles           # 每辆车的载重
    unvisited = set(range(1, n_nodes))       # 未访问的客户
  
    for vehicle in range(n_vehicles):
        current_pos = 0  # 从配送中心开始
      
        while unvisited:
            # 找到最近的可行客户
            best_customer = None
            best_distance = float('inf')
          
            for customer in unvisited:
                # 检查载重约束和距离
                if (route_loads[vehicle] + demands[customer-1] <= vehicle_capacity and
                    distance_matrix[current_pos][customer] < best_distance):
                    best_customer = customer
                    best_distance = distance_matrix[current_pos][customer]
          
            if best_customer is None:
                break  # 当前车辆无法再装载
          
            # 添加客户到路线
            routes[vehicle].append(best_customer)
            route_loads[vehicle] += demands[best_customer-1]
            current_pos = best_customer
            unvisited.remove(best_customer)
```

**算法步骤**：

1. **初始化**：每辆车从配送中心出发，载重为0
2. **贪心选择**：对每辆车，总是选择最近的可行客户
3. **可行性检查**：确保添加客户后不超过载重限制
4. **更新状态**：更新车辆位置、载重和未访问客户列表
5. **返回配送中心**：每辆车完成配送后返回配送中心

---

# 投资组合优化问题

## 问题背景

投资者有100万元资金，可以投资30只股票，每只股票有不同的预期收益和风险。问题是：**如何分配投资比例，在达到10%目标收益率的前提下，使投资风险最小？**

该问题属于现代投资组合理论的典型应用。

## 核心代码实现

### 1. 金融数据生成

**关键代码**：

```python
def portfolio_optimization(self):
    # 股票数据
    n_stocks = 30
    stocks = [f'股票_{i+1:02d}' for i in range(n_stocks)]
  
    # 预期收益率：基于正态分布，平均8%
    expected_returns = np.random.normal(0.08, 0.05, n_stocks)
    expected_returns = np.maximum(expected_returns, 0.01)  # 确保为正
  
    # 风险（标准差）：10%-40%
    risks = np.random.uniform(0.1, 0.4, n_stocks)
  
    # 投资约束
    total_budget = 1000000    # 100万元
    min_weight = 0.01         # 最小权重1%
    max_weight = 0.15         # 最大权重15%
    target_return = 0.10      # 目标收益率10%
```

**说明**：

- `np.random.normal(0.08, 0.05, n_stocks)`：股票收益率围绕8%正态分布
- `min_weight = 0.01`：每只股票至少投资1%，避免过度分散
- `max_weight = 0.15`：每只股票最多投资15%，控制集中度风险

### 2. 投资组合优化模型

**关键代码步骤**：

**步骤1：创建优化问题**

```python
prob = pulp.LpProblem("投资组合优化", pulp.LpMinimize)
```

- 目标是最小化投资组合风险

**步骤2：定义权重变量**

```python
weights = [pulp.LpVariable(f"w_{i}", lowBound=min_weight, upBound=max_weight) 
          for i in range(n_stocks)]
```

- `weights[i]`：投资于股票i的资金比例
- `lowBound`和 `upBound`：权重的上下限约束

**步骤3：目标函数（风险最小化）**

```python
# 简化的风险度量（线性近似）
prob += pulp.lpSum([risks[i] * weights[i] for i in range(n_stocks)])
```

- 实际应用中应使用二次规划求解真正的方差最小化

**步骤4：约束条件**

```python
# 权重和为1（100%投资）
prob += pulp.lpSum(weights) == 1

# 达到目标收益率
prob += pulp.lpSum([expected_returns[i] * weights[i] 
                   for i in range(n_stocks)]) >= target_return
```

### 3. 结果分析

**计算组合指标**：

```python
optimal_weights = [w.varValue for w in weights]
portfolio_return = sum(expected_returns[i] * optimal_weights[i] 
                      for i in range(n_stocks))
portfolio_risk = np.sqrt(np.dot(optimal_weights, np.dot(cov_matrix, optimal_weights)))

# 夏普比率（收益风险比）
sharpe_ratio = (portfolio_return - 0.03) / portfolio_risk  # 假设无风险利率3%
```

## 完整运行方法

### 运行所有四个问题

```bash
cd 大规模优化
python large_scale_optimization.py
```

### 单独运行某个问题

```python
from large_scale_optimization import LargeScaleOptimization
demo = LargeScaleOptimization()

# 选择运行其中一个
demo.large_scale_linear_programming()      # 多产品生产计划
demo.large_scale_transportation()          # 全国物流网络
demo.vehicle_routing_problem()             # 车辆路径规划
demo.portfolio_optimization()              # 投资组合优化
```

## 综合输出结果

运行完整程序后将显示四个问题的对比摘要：

```
算法性能对比：
     算法     问题规模 求解时间(秒)       目标值   活跃变量
大规模线性规划    50×20   0.016    97,663  10/50
大规模运输问题    15×25   0.016 5,324,479 39/375
 车辆路径问题 20客户×4车辆 < 0.001     606.5    4/4
 投资组合优化     30股票 < 0.001    10.00%   6/30
```

**结果对比分析**：

- **线性规划**：50种产品中只有10种值得生产，体现了资源稀缺性
- **运输问题**：375条可能路线中只有39条活跃，网络高度优化
- **车辆路径**：使用贪心算法快速求解，4辆车全部使用
- **投资组合**：30只股票中只有6只获得显著配置，符合集中投资原理

## 可视化图表说明

程序生成的 `large_scale_results.png` 包含 6 个子图：

1. **产量分布直方图**：显示活跃产品的产量分布
2. **资源利用率热力图**：显示哪些资源是瓶颈（颜色越深利用率越高）
3. **运输网络图**：显示活跃的运输路线
4. **车辆路径图**：显示每辆车的配送路线
5. **投资权重分布**：显示投资组合的权重分布
6. **风险收益散点图**：显示各股票的风险收益特征，气泡大小表示投资权重
