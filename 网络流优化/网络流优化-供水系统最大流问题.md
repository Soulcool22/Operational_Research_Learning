# 网络流优化｜供水系统最大流问题

## 问题背景
网络流问题在现实中很常见：
- **供水系统**：水从水源流向用户，管道有容量限制，怎样让流量最大？
- **物流配送**：货物从仓库运到客户，运输有成本和容量，怎样让成本最小？
- **交通导航**：从起点到终点，道路有距离，怎样让路程最短？

本模块提供三个函数：最大流、最小费用流与最短路径。

## 核心代码实现

### 1. 最大流问题：`solve_max_flow_problem()`

**作用**：在管道容量限制下，计算从水源到用户的最大供水量。

**关键代码步骤**：

**步骤1：构建网络图**
```python
import networkx as nx

G = nx.DiGraph()  # 有向图，水流有方向

# 节点：水源S，中间节点A,B,C,D，用户T
nodes = ['S', 'A', 'B', 'C', 'D', 'T']
G.add_nodes_from(nodes)

# 边和容量：(起点, 终点, 管道容量)
edges_capacity = [
    ('S', 'A', 16), ('S', 'B', 13),  # 水源到中间节点
    ('A', 'B', 4), ('A', 'C', 12),   # 中间节点互连
    ('B', 'D', 14), ('C', 'B', 9),
    ('C', 'T', 20), ('D', 'C', 7),   # 中间节点到用户
    ('D', 'T', 4)
]

# 添加边，每条边有容量属性
for start, end, capacity in edges_capacity:
    G.add_edge(start, end, capacity=capacity, flow=0)
```

**步骤2：求解最大流**
```python
# 使用NetworkX的最大流算法（Edmonds-Karp算法）
max_flow_value, max_flow_dict = nx.maximum_flow(G, 'S', 'T')

print(f"最大流量: {max_flow_value} 单位/小时")
```

**步骤3：分析流量分配**
```python
# 查看每条管道的流量使用情况
for start in max_flow_dict:
    for end in max_flow_dict[start]:
        flow = max_flow_dict[start][end]  # 实际流量
        if flow > 0:
            capacity = G[start][end]['capacity']  # 管道容量
            utilization = flow / capacity * 100   # 利用率
            print(f"{start} → {end}: {flow}/{capacity} (利用率: {utilization:.1f}%)")
```

**步骤4：找出瓶颈管道**
```python
# 找出满负荷运行的管道（瓶颈）
bottleneck_edges = []
for detail in flow_details:
    if detail['utilization'] >= 99.9:  # 利用率接近100%
        bottleneck_edges.append(detail)
        print(f"瓶颈管道: {detail['from']} → {detail['to']}")
```

**说明**：
- `nx.DiGraph()`：有向图，表示流动方向。
- `maximum_flow()`：使用 Edmonds-Karp 算法计算最大流。
- 瓶颈分析：识别限制整体流量的关键管道。

### 2. 最小费用流问题：`solve_min_cost_flow_problem()`

**作用**：在满足供需的前提下，找到运输成本最低的配送方案。

**关键代码步骤**：

**步骤1：定义供需数据**
```python
# 仓库供应量
supply = {'仓库1': 100, '仓库2': 150}

# 客户需求量
demand = {'客户A': 80, '客户B': 90, '客户C': 80}

# 运输数据：(起点, 终点, 单位成本, 容量限制)
transport_data = [
    ('仓库1', '客户A', 4, 60),  # 仓库1到客户A：4元/单位，最多60单位
    ('仓库1', '客户B', 6, 70),
    ('仓库1', '客户C', 8, 50),
    ('仓库2', '客户A', 5, 50),
    ('仓库2', '客户B', 3, 80),  # 最便宜的路线
    ('仓库2', '客户C', 7, 60)
]
```

**步骤2：建立优化模型**
```python
import pulp

# 创建最小化问题
prob = pulp.LpProblem("最小费用流问题", pulp.LpMinimize)

# 决策变量：每条路线的运输量
x = {}
for start, end, cost, capacity in transport_data:
    x[start, end] = pulp.LpVariable(f"x_{start}_{end}", 
                                  lowBound=0,        # 非负
                                  upBound=capacity)  # 不超过容量

# 目标函数：最小化总运输成本
prob += pulp.lpSum([cost * x[start, end] 
                   for start, end, cost, capacity in transport_data])
```

**步骤3：添加约束条件**
```python
# 供应约束：每个仓库的出货量不能超过供应量
for warehouse in warehouses:
    prob += pulp.lpSum([x[warehouse, customer] 
                       for customer in customers 
                       if (warehouse, customer) in x]) <= supply[warehouse]

# 需求约束：每个客户的收货量必须满足需求
for customer in customers:
    prob += pulp.lpSum([x[warehouse, customer] 
                       for warehouse in warehouses 
                       if (warehouse, customer) in x]) >= demand[customer]
```

**步骤4：求解和结果分析**
```python
# 求解
prob.solve(pulp.PULP_CBC_CMD(msg=0))

# 获取结果
min_cost = pulp.value(prob.objective)
print(f"最小运输成本: {min_cost:.2f} 元")

# 查看最优配送方案
for start, end, cost, capacity in transport_data:
    flow = x[start, end].varValue  # 获取变量的最优值
    if flow > 0:
        total_cost = flow * cost
        print(f"{start} → {end}: {flow:.1f}单位, 成本: {total_cost:.2f}元")
```

**说明**：
- `LpVariable()`：决策变量，表示各路线运输量。
- `lpSum()`：求和函数，用于计算总成本或总流量。
- 约束条件：保证供应不超量、需求得到满足。
- `.varValue`：获取优化后变量的取值。

### 3. 最短路径问题：`solve_shortest_path_problem()`

**作用**：在城市交通网络中，找到两点间的最短路径。

**关键代码步骤**：

**步骤1：构建交通网络**
```python
G = nx.Graph()  # 无向图，道路可以双向通行

# 城市节点
cities = ['起点', '城市A', '城市B', '城市C', '城市D', '终点']
G.add_nodes_from(cities)

# 道路和距离：(城市1, 城市2, 距离km)
roads = [
    ('起点', '城市A', 10), ('起点', '城市B', 15),
    ('城市A', '城市C', 12), ('城市A', '城市D', 15),
    ('城市B', '城市C', 8), ('城市B', '城市D', 7),
    ('城市C', '终点', 10), ('城市D', '终点', 12),
    ('城市A', '城市B', 6), ('城市C', '城市D', 5)
]

# 添加边，权重为距离
for city1, city2, distance in roads:
    G.add_edge(city1, city2, weight=distance)
```

**步骤2：计算最短路径**
```python
# 使用Dijkstra算法求最短路径
shortest_path = nx.shortest_path(G, '起点', '终点', weight='weight')
shortest_distance = nx.shortest_path_length(G, '起点', '终点', weight='weight')

print(f"最短距离: {shortest_distance} km")
print(f"最短路径: {' → '.join(shortest_path)}")
```

**步骤3：分析路径详情**
```python
# 逐段分析路径
path_details = []
total_distance = 0

for i in range(len(shortest_path) - 1):
    start = shortest_path[i]
    end = shortest_path[i + 1]
    distance = G[start][end]['weight']  # 获取边的权重
    total_distance += distance
    
    print(f"第{i+1}段: {start} → {end}, {distance} km (累计: {total_distance} km)")
```

**步骤4：网络连通性分析**
```python
# 分析整个网络的特性
print(f"网络直径: {nx.diameter(G, weight='weight'):.1f} km")  # 最远两点距离
print(f"平均路径长度: {nx.average_shortest_path_length(G, weight='weight'):.1f} km")
```

**说明**：
- `nx.Graph()`：无向图，表示道路双向通行。
- `shortest_path()`：使用 Dijkstra 算法查找最短路径。
- `weight='weight'`：指定边权重属性为距离。
- 网络直径：网络中任意两点的最大距离。

### 4. 可视化结果：`visualize_results()`

**作用**：把抽象的网络流结果画成直观的图表。

**关键代码步骤**：

**步骤1：最大流网络图**
```python
# 设置节点位置，让图形更美观
pos = {
    'S': (0, 1),      # 水源在左边
    'A': (1, 1.5),    # 中间节点
    'B': (1, 0.5),
    'C': (2, 1.5),
    'D': (2, 0.5),
    'T': (3, 1)       # 用户在右边
}

# 绘制节点
nx.draw_networkx_nodes(G, pos, node_color='lightblue', node_size=1000)
nx.draw_networkx_labels(G, pos, font_size=12)
```

**步骤2：根据流量调整边的显示**
```python
for start, end in G.edges():
    flow = max_flow_dict[start][end]  # 获取流量
    capacity = G[start][end]['capacity']
    
    if flow > 0:
        width = max(1, flow / 5)  # 流量越大，线条越粗
        nx.draw_networkx_edges(G, pos, [(start, end)], 
                             width=width, edge_color='red')
        
        # 添加流量标签
        x1, y1 = pos[start]
        x2, y2 = pos[end]
        ax.text((x1+x2)/2, (y1+y2)/2, f'{flow}/{capacity}', 
               fontsize=8, ha='center')
    else:
        # 没有流量的边用虚线显示
        nx.draw_networkx_edges(G, pos, [(start, end)], 
                             width=1, edge_color='gray', style='dashed')
```

**步骤3：最短路径高亮显示**
```python
# 高亮最短路径
shortest_path = sp_data['shortest_path']
path_edges = [(shortest_path[i], shortest_path[i+1]) 
             for i in range(len(shortest_path)-1)]

# 用红色粗线显示最短路径
nx.draw_networkx_edges(G, pos, path_edges, 
                     edge_color='red', width=3)

# 路径上的节点用红色标记
node_colors = ['red' if node in shortest_path else 'lightblue' 
              for node in G.nodes()]
nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=800)
```

**说明**：
- `pos`：手动设置节点位置以改善布局。
- 线条粗细：根据流量大小调整线宽。
- 颜色编码：红色强调重要线路，灰色表示非关键线路。

## 运行方法

### 运行所有功能
```bash
cd 网络流优化
python network_flow_demo.py
```

### 单独运行某个功能
```python
from network_flow_demo import NetworkFlowDemo
demo = NetworkFlowDemo()

# 选择运行其中一个
max_flow_value, max_flow_dict = demo.solve_max_flow_problem()    # 最大流
min_cost, flow_solution = demo.solve_min_cost_flow_problem()     # 最小费用流
shortest_path, distance = demo.solve_shortest_path_problem()     # 最短路径

# 生成图表
demo.visualize_results()
```

## 输出结果说明

### 控制台输出
运行后会显示详细的求解过程和结果：

**最大流问题**：
```
最大流问题 - 供水网络优化
网络结构：
节点：水源 S → 中间节点 A、B、C、D → 用户 T
边容量（管道最大流量）：
  S → A：16 单位/小时
  S → B：13 单位/小时
  ...

最大流结果：
  最大流量：19 单位/小时

最优流量分配：
  S → A：12.0/16（利用率：75.0%）
  S → B：7.0/13（利用率：53.8%）
  ...

网络瓶颈：
  C → T：满负荷运行
```

**最小费用流问题**：
```
最小费用流问题 - 物流配送优化
供需信息：
仓库供应量：{'仓库1': 100, '仓库2': 150}
客户需求量：{'客户A': 80, '客户B': 90, '客户C': 80}

最小费用流结果：
  最小运输成本：1230.00 元

最优配送方案：
  仓库1 → 客户 A：60.0 单位，成本：240.00 元
  仓库2 → 客户 B：90.0 单位，成本：270.00 元
  ...
```

**最短路径问题**：
```
最短路径问题 - 城市交通网络
最短路径结果：
  最短距离：25 km
  最短路径：起点 → 城市 B → 城市 D → 终点

  第 1 段：起点 → 城市 B，15 km（累计：15 km）
  第 2 段：城市 B → 城市 D，7 km（累计：22 km）
  第 3 段：城市 D → 终点，12 km（累计：34 km）
```

### 图表文件
运行后会生成 `network_flow_results.png` 文件，包含：

1. **最大流网络图**
   - 节点：蓝色圆圈表示网络节点
   - 边：红色粗线表示有流量的管道，线条粗细表示流量大小
   - 标签：显示"实际流量/管道容量"

2. **最短路径网络图**
   - 节点：红色表示在最短路径上，蓝色表示不在路径上
   - 边：红色粗线表示最短路径，灰色细线表示其他道路
   - 标签：显示道路距离

## 算法原理简介

### 最大流算法（Edmonds-Karp）
- **基本思想**：不断寻找从源点到汇点的增广路径，直到找不到为止
- **增广路径**：还有剩余容量的路径
- **最大流=最小割**：网络的最大流量等于最小割的容量

### 最小费用流算法
- **基本思想**：在满足流量需求的前提下，选择成本最低的路径组合
- **线性规划**：用PuLP库建立线性规划模型求解
- **约束条件**：供应约束、需求约束、容量约束

### 最短路径算法（Dijkstra）
- **基本思想**：从起点开始，逐步扩展到距离最近的未访问节点
- **贪心策略**：每次选择当前距离最短的节点
- **适用范围**：边权重非负的图

## 实际应用场景

### 供水系统设计
- **问题**：设计管网，确保供水量最大
- **解决方案**：用最大流算法找出瓶颈管道，指导扩容决策

### 物流配送优化
- **问题**：多仓库配送多客户，最小化运输成本
- **解决方案**：用最小费用流算法优化配送路线

### 交通路径规划
- **问题**：导航系统找最短路径
- **解决方案**：用最短路径算法实时计算最优路线

## 技术要点

### NetworkX图论库
```python
import networkx as nx

# 有向图：流量有方向
G = nx.DiGraph()

# 无向图：道路可双向通行
G = nx.Graph()

# 添加边和属性
G.add_edge('A', 'B', capacity=10, cost=5, weight=3)
```

### PuLP优化库
```python
import pulp

# 创建问题
prob = pulp.LpProblem("问题名称", pulp.LpMinimize)

# 创建变量
x = pulp.LpVariable("x", lowBound=0, upBound=100)

# 添加目标函数
prob += 3 * x + 2 * y

# 添加约束
prob += x + y <= 10

# 求解
prob.solve()
```

### 图形可视化
```python
# 设置中文字体
setup_chinese_font()

# 统一样式
plt.style.use('seaborn-v0_8')

# 高质量保存
plt.savefig('filename.png', dpi=300, bbox_inches='tight')
```

